<!doctype html>
<html>
<head>
<meta charset='utf-8'/>
<title>CSChat</title>
<style>
	:root { --bg:#111; --fg:#eee; }
	html, body { height: 100%; margin: 0; overflow: hidden; }
	body { display: grid; grid-template-rows: auto 1fr auto; }
	#main { display:flex; flex-direction:column; min-height:0; }
	#console { display:flex; flex-direction:column; align-items:flex-start; gap:10px; flex:1; min-height:0; overflow:auto; padding:12px; }
	#composer { display:flex; gap:8px; padding:8px 12px; border-top:none; background:transparent; }
	#t{ flex:1; font:inherit; padding:10px 14px; border:1px solid #d9d9d9; border-radius:9999px; outline:none; background:#fff; box-shadow: inset 0 1px 2px rgba(0,0,0,.06); }
	#t:focus{ border-color:#b9cdfd; box-shadow:0 0 0 2px rgba(80,140,255,.15), inset 0 1px 2px rgba(0,0,0,.06); }
	#send{ padding:8px 14px; border:1px solid #d9d9d9; border-radius:9999px; background:#f6f6f6; font:inherit; cursor:pointer;}
	#send:hover{background:#f0f0f0;} #send:active{background:#eaeaea;}
	pre{margin:0 0 8px 0; white-space:pre-wrap;}
	
	/* message bubbles */
	#console>.bubble{ white-space:normal; margin:0; padding:10px 12px; border-radius:10px; line-height:1.35; word-break:break-word; background:#1b1b1b; border:1px solid #333; color:var(--fg); max-width:min(90ch,85%); align-self:flex-start; font-family:system-ui,sans-serif; }
	#console .bubble>:first-child{margin-top:0;} #console .bubble>:last-child{margin-bottom:0;}
	#console>.bubble.user{ align-self:flex-end; background:#1d80ea; border-color:#1d80ea; color:#fafafa;}
	#console>.bubble.assistant{ background:#eee; border-color:#eee; color:#000;}
	#console>.bubble.system{ align-self:stretch; max-width:80%; background:#ddd; border-style:dashed; color:#000;}

	/* tool bubbles scroll horizontally if they must, but prefer wrapping first */
	#console>.bubble.tool { color: #000; --pad-top: 10px; padding:var(--pad-top) 12px 10px 12px; align-self: stretch; width: auto; max-width: 100%; box-sizing: border-box; text-align: left; background: #eee; border-color: #eee; font-weight: 500; overflow-wrap: anywhere; max-height: 65vh; min-height: 220px; overflow: auto; overflow-x: auto; }
	#console .bubble.tool h1,
	#console .bubble.tool h2,
	#console .bubble.tool h3,
	#console .bubble.tool h4,
	#console .bubble.tool h5,
	#console .bubble.tool h6 { color:#000; }

	/* tables: fixed layout + wrapping cells = stable widths */
	#console .bubble.tool table { width: 100%; border-collapse: collapse; table-layout: fixed; font-weight: normal; }

	/* cells: wrap, don't clip; let URLs break nicely */
	#console .bubble.tool th,
	#console .bubble.tool td { border: 1px solid #333; padding: 6px 8px; text-align: left; vertical-align: top; white-space: normal; overflow-wrap: anywhere; word-break: break-word; hyphens: auto; color:#000;}
	
	/* lighter, clearer stripes and header */
	#console .bubble.tool th { background: #ddd; }
	#console .bubble.tool tr:nth-child(even) td { background: #f5f5f5; color:#000; }

	/* sticky header for tall tables */
	#console .bubble.tool thead th { position: sticky; top: calc(-1 * var(--pad-top)); z-index: 2; background: #ddd; box-shadow: 0 1px 0 #333 inset; }

	/* menu overlay */ 
	#menuOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.0); pointer-events:none; z-index:9999; }
	#menuPanel{ position:absolute; top:-90%; left:50%; transform:translateX(-50%); width:min(760px,92vw); max-height:min(70vh,600px); background:#fff; color:#000; border-radius:0 0 10px 10px; box-shadow:0 20px 50px rgba(0,0,0,.35); display:grid; grid-template-rows:auto auto 1fr auto; overflow:hidden; transition:top .3s ease-in-out; }
	#menuOverlay.active{ pointer-events:auto; } #menuOverlay.active #menuPanel{ top:0; }
	#menuList{ list-style:none; margin:0; padding:6px 8px 12px 8px; overflow:auto; }
	#menuHeader{ padding:12px 14px; font-weight:600; background:#111; color:#eee; }
	#menuFilter{ margin:10px; padding:10px; font:inherit; border:1px solid #ccc; border-radius:8px; }
	#menuList li{ padding:8px 10px; border-radius:8px; opacity:1; transform:translateY(0); transition:opacity .2s ease, transform .2s ease; }
	#menuList li.fade-out{ opacity:0; transform:translateY(-10px); } #menuList li.fade-in{ opacity:0; transform:translateY(10px); animation:fadeInMove .2s forwards; }
	@keyframes fadeInMove{ to{ opacity:1; transform:translateY(0);} }
	#menuList li[data-active="true"]{ background:#111; color:#fff; }
	#menuHint{ padding:8px 12px; font-size:.9em; color:#444; border-top:1px solid #eee; background:#fafafa; }
	#menuTab{ position:fixed; top:0; left:50%; transform:translateX(-50%); background:#111; color:#eee; padding:4px 10px; font-size:.85em; border-radius:0 0 6px 6px; cursor:pointer; z-index:9998; }
	#menuOverlay.active ~ #menuTab { display:none; }

	/* form overlay */
	#formOverlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.55); z-index:10000; }
	#formPanel{ background:#fff; color:#000; width:min(840px,92vw); max-height:min(80vh,720px); display:grid; grid-template-rows:auto 1fr auto; border-radius:12px; overflow:hidden; box-shadow:0 30px 70px rgba(0,0,0,.45);}
	#formTitle{ padding:14px 16px; background:#111; color:#eee; font-weight:700; }
	#formBody{ overflow:auto; padding:12px 16px; }
	#formFooter{ padding:10px 16px; display:flex; gap:8px; justify-content:flex-end; border-top:1px solid #eee; background:#fafafa; }
	.field-error{ color:#b00020; font-size:.9em; margin-top:4px; grid-column:2; }
	input.invalid, select.invalid, textarea.invalid { border-color:#b00020 !important; outline:none; box-shadow:0 0 0 2px rgba(176,0,32,.15); }
	.array-toolbar { display:flex; gap:6px; }
	.array-list { list-style:none; margin:6px 0 0 0; padding:0; border:1px solid #eee; max-height:200px; overflow:auto; }
	.array-list li { display:flex; justify-content:space-between; gap:8px; padding:6px 8px; border-bottom:1px solid #f1f1f1; }
	.array-actions button { margin-left:6px; }
</style>
</head>
<body>
	<header></header>
	<div id="menuTab">press ESC key to open</div>
	<div id='main'>
		<div id='console'> <!-- big scrollable console/log -->
	</div>
	<div id='composer'>
		<input id='t' placeholder='Type and press Enter'/>
		<button id='send'>Send</button>
	</div>
	<!-- MENU OVERLAY -->
	<div id="menuOverlay" hidden>
		<div id="menuPanel">
			<div id="menuHeader"></div>
			<input id="menuFilter" placeholder="[filter]" autocomplete="off" />
			<ul id="menuList"></ul>
			<div id="menuHint">↑/↓ select • Enter choose • Esc back/cancel</div>
		</div>
	</div>
	<!-- FORM OVERLAY -->
	<div id="formOverlay" hidden>
		<div id="formPanel">
			<div id="formTitle"></div>
			<div id="formBody"></div>
			<div id="formFooter">
				<button id="formCancel">Cancel</button>
				<button id="formSubmit" disabled>Submit</button>
			</div>
		</div>
	</div>
<script src="marked.min.js"></script>
<script>
	const consoleEl = document.getElementById('console');
	const t = document.getElementById('t');
	const send = document.getElementById('send');

	function post(obj) { try { window.external?.sendMessage?.(JSON.stringify(obj)); } catch {} }
	// requestId -> (files:string[]) => void
	const pendingPickers = new Map();	
	function cwrite(s){ consoleEl.textContent += (s ?? ''); consoleEl.scrollTop = consoleEl.scrollHeight; }
	function cwriteline(s){ cwrite((s ?? '') + '\\n'); }

	// --- menu controller ---------------------------------------------------------
	const menuOverlay = document.getElementById('menuOverlay');
	const menuHeader  = document.getElementById('menuHeader');
	const menuFilter  = document.getElementById('menuFilter');
	const menuList    = document.getElementById('menuList');

	let menuState = null;         // { header, choices, filtered, idx }

	document.getElementById('menuTab').onclick = () => {
		post({ type:'Key', key:'Escape' }); // mimic ESC keypress to open menu
	};

	function openMenu(payload) {
		menuState = {
			header: payload.header || 'Menu',
			choices:[...(payload.choices || [])],
			filtered:[...(payload.choices || [])],
			idx: Math.min(Math.max(0, payload.selected|0), (payload.choices||[]).length-1)
		};

		menuHeader.textContent = menuState.header;
		menuFilter.value = '';
		renderMenu();
		menuOverlay.hidden = false;
		menuOverlay.classList.add('active');
		// Trap focus & keystrokes while menu is open
		document.body.style.overflow = 'hidden';
		t.disabled = true;
		menuFilter.focus();
	}

	function closeMenu(sendResult) {
		menuOverlay.classList.remove('active');
		menuOverlay.hidden = true;
		if (sendResult !== undefined) post({ type:'MenuResult', text: sendResult ?? null });
		document.body.style.overflow = '';
		t.disabled = false;
		t.focus();
	}
	function renderMenu() {
		const q = menuFilter.value.trim().toLowerCase();
		const newItems = q
			? menuState.choices.filter(c => c.toLowerCase().includes(q))
			: menuState.choices.slice();

		// Keep filtered in sync for chooseActive()
		menuState.filtered = newItems;

		// Clamp idx if needed
		if (menuState.filtered.length === 0) menuState.idx = 0;
		else if (menuState.idx >= menuState.filtered.length) menuState.idx = menuState.filtered.length - 1;

		const oldLis   = [...menuList.querySelectorAll('li')];
		const oldTexts = oldLis.map(li => li.dataset.value);

		// Fade-out removes
		oldLis.forEach(li => {
			if (!newItems.includes(li.dataset.value)) {
				li.classList.add('fade-out');
				setTimeout(() => li.remove(), 200);
			}
		});

		// Add missing items (fade-in)
		newItems.forEach((c, i) => {
			if (!oldTexts.includes(c)) {
				const li = document.createElement('li');
				li.dataset.value = c;  // stable key
				li.textContent = c;
				li.classList.add('fade-in');
				li.onclick = () => { menuState.idx = i; chooseActive(); };
				menuList.appendChild(li);
			}
		});

		// Reindex & active state on all survivors (order matters)
		const lis = [...menuList.querySelectorAll('li')];
		lis.sort((a,b) => newItems.indexOf(a.dataset.value) - newItems.indexOf(b.dataset.value))
			.forEach((li, i) => {
				li.textContent = li.dataset.value;
				li.dataset.active = (i === menuState.idx ? 'true' : 'false'); li.onclick=()=>{ menuState.idx=i; chooseActive(); }; });
		const active = menuList.querySelector('li[data-active="true"]');
		if (active){
			const r=active.getBoundingClientRect(), pr=menuList.getBoundingClientRect();
			if (r.top<pr.top) menuList.scrollTop += r.top-pr.top;
			else if (r.bottom>pr.bottom) menuList.scrollTop += r.bottom-pr.bottom;
		}
	}
	function chooseActive() {
		const items = menuState.filtered;
		const chosen = (items.length > 0) ? items[menuState.idx] : null;
		closeMenu(chosen);
	}

	// Filter typing
	menuFilter.addEventListener('input', renderMenu);

	// Keyboard in the menu
	menuOverlay.addEventListener('keydown', (e) => {
		// Prevent these from leaking to the host while overlay is open
		if (['ArrowUp','ArrowDown','PageUp','PageDown','Home','End','Escape','Enter'].includes(e.key)) {
			e.stopPropagation(); e.preventDefault();
		}
		const len = menuState.filtered.length;
		switch (e.key){
			case 'ArrowUp':	 	if (len) menuState.idx = Math.max(0,menuState.idx-1); renderMenu(); break;
			case 'ArrowDown': 	if (len) menuState.idx = Math.min(len-1,menuState.idx+1); renderMenu(); break;
			case 'PageUp':	 	if (len) menuState.idx = Math.max(0,menuState.idx-10); renderMenu(); break;
			case 'PageDown': 	if (len) menuState.idx = Math.min(len-1,menuState.idx+10); renderMenu(); break;
			case 'Home':	 	if (len) menuState.idx = 0; renderMenu(); break;
			case 'End':	 		if (len) menuState.idx = len-1; renderMenu(); break;
			case 'Enter':	 	chooseActive(); break;
			case 'Escape':	 	closeMenu(null); break; // close this menu, let host know it was cancelled
		}
	});

	// Close if user clicks outside the panel
	menuOverlay.addEventListener('click', (e) => {
		if (e.target === menuOverlay) closeMenu(null);
	});
	// --- end menu controller ------------------------------------------------------
	// --- form controller ---------------------------------------------------------
	const formOverlay = document.getElementById('formOverlay');
	const formTitle   = document.getElementById('formTitle');
	const formBody    = document.getElementById('formBody');
	const formCancel  = document.getElementById('formCancel');
	const formSubmit  = document.getElementById('formSubmit');

	let formState = null;              // { fields:[...] }
	const idByKey = new Map();         // key -> element id
	const errByKey = new Map();        // key -> error <div>

	function openForm(payload) {
		formTitle.textContent = payload.title || 'Input';
		formBody.innerHTML = '';
		formOverlay.style.display = 'flex';
		document.body.style.overflow = 'hidden';

		idByKey.clear(); errByKey.clear();

		const fields = (payload.fields || []).map(f => ({ ...f, id: 'f_' + Math.random().toString(36).slice(2) }));
		formState = { fields };

		for (const f of fields) {
			const row = document.createElement('div');
			row.style.display = 'grid';
			row.style.gridTemplateColumns = '220px 1fr';
			row.style.columnGap = '12px';
			row.style.rowGap = '2px';
			row.style.marginBottom = '12px';
			row.style.alignItems = 'center';

			// label
			const lab = document.createElement('label');
			lab.textContent = f.label + (f.required ? ' *' : '');
			lab.setAttribute('for', f.id);
			row.appendChild(lab);

			// --- inputs by kind ---
			let input; const kind = String(f.kind||'').toLowerCase();

			const addHelp = (node) => {
				const help = document.createElement('div');
				help.textContent = f.help || '';
				help.style.gridColumn = '1 / span 2';
				help.style.color = '#555'; help.style.fontSize = '.92em'; help.style.padding = '4px 2px 0 2px';
				row.appendChild(help);
				return help;
			};
			const addError = () => {
				const err = document.createElement('div');
				err.className = 'field-error';
				err.style.display = 'none';
				row.appendChild(err);
				errByKey.set(f.key, err);
			};

			if (kind === 'text'){
				input = document.createElement('textarea');
				input.rows = 4;
				input.value = f.current ?? '';
			} else if (kind === 'number') {
				input = document.createElement('input');
				input.type = 'number';
				if (f.min != null) input.min = String(f.min);
				if (f.max != null) input.max = String(f.max);
				input.value = f.current ?? '';
			} else if (kind === 'decimal') {
				input = document.createElement('input');
				input.type = 'number';
				input.step = 'any';
				input.value = f.current ?? '';
			} else if (kind === 'long') {
				input = document.createElement('input');
				input.type = 'number';
				input.step = '1';
				input.value = f.current ?? '';
			} else if (kind === 'bool') {
				input = document.createElement('select');
				['false','true'].forEach(v => { const o=document.createElement('option'); o.value=v; o.textContent=v; input.appendChild(o); });
				input.value = String(f.current ?? 'false');
			} else if (kind === 'enum') {
				input = document.createElement('select');
				(f.choices || []).forEach(v => { const o=document.createElement('option'); o.value=v; o.textContent=v; input.appendChild(o); });
				if (f.current != null) input.value = String(f.current);
			} else if (kind === 'date') {
				input = document.createElement('input');
				input.type = 'date';
				input.value = f.current ?? '';
			} else if (kind === 'time') {
				input = document.createElement('input');
				input.type = 'time';
				input.value = f.current ?? '';
			} else if (kind === 'guid') {
				input = document.createElement('input');
				input.type = 'text';
				input.value = f.current ?? '';
			} else if (kind === 'password') {
				input = document.createElement('input');
				input.type = 'password';
				input.value = f.current ?? ''; 
			} else if (kind === 'path') {
				const wrap = document.createElement('div');
				wrap.style.display = 'grid';
				wrap.style.gridTemplateColumns = '1fr auto';
				wrap.style.gap = '8px';
				input=document.createElement('input');
				input.type = 'text';
				input.value = f.current ?? '';
				const mode = f.pathMode ?? 'OpenExisting';
				const btn = document.createElement('button');
				btn.type = 'button';
				btn.textContent = 'Browse…';
				btn.addEventListener('click', () => {
					const reqId = Math.random().toString(36).slice(2);
					pendingPickers.set(reqId, (files) => {
						if (files && files.length) {
							input.value = files[0];
							validateForm();
						}
					});
					// You can pass filters here if you want (e.g., ["*.csv","*.txt"])
          post({ type:'PickFiles', requestId:reqId, options:{ multi:false, pathMode: mode } });
				});
				wrap.appendChild(input);
				wrap.appendChild(btn);
				row.appendChild(wrap);
				addHelp(wrap);
				addError();
				gotoFinalize();
				continue;
			} else if (kind === 'array')
			{ 
				// list
				const container = document.createElement('div');
				container.style.display = 'block';
				const list = document.createElement('ul');
				list.className='array-list';

				let items = [];
				try {
					items = JSON.parse(f.current||'[]') || [];
				} catch { 
					items = []; 
				}

				function renderList(){
					list.innerHTML = '';
					items.forEach((v,i)=>{
						const li=document.createElement('li');
						const span=document.createElement('span'); 
						span.textContent = String(v);

						const actions=document.createElement('div'); 
						actions.className='array-actions';

						const e=document.createElement('button'); 
						e.type='button'; 
						e.textContent='✎'; 
						e.title='Edit';

						const r=document.createElement('button'); 
						r.type='button'; 
						r.textContent='✕';
						r.title='Remove';

						e.onclick=()=>editItem(i); 
						r.onclick=()=>{ 
							items.splice(i,1); 
							renderList(); 
							validateForm();
						};

						actions.appendChild(e);
						actions.appendChild(r);
						li.appendChild(span);
						li.appendChild(actions);
						list.appendChild(li);
					});
				}

				function editItem(i){
					const curr = (i>=0)? String(items[i]) : '';
					const val = prompt('Value:', curr);
					if (val==null) return;
					if (i>=0) items[i]=val; else items.push(val);
					renderList();
					validateForm();
				}

				// single add button at the bottom
				const addRow = document.createElement('div');
				addRow.style.display = 'flex';
				addRow.style.justifyContent = 'flex-end';
				addRow.style.marginTop = '6px';
				const addBtn = document.createElement('button');
				addBtn.type = 'button';
				addBtn.textContent = '+';
				addBtn.title = 'Add';
				addBtn.onclick = () => editItem(-1);
				addRow.appendChild(addBtn);

				renderList();

				container.appendChild(list);
				container.appendChild(addRow);

				// hidden backing input to carry JSON on submit
				input = document.createElement('input');
				input.type='hidden';
				input.value = JSON.stringify(items);

				container.appendChild(input);
				row.appendChild(container);
				
				addHelp(container); 
				addError();
				gotoFinalize(false /*no generic placement*/ , input, () => { input.value = JSON.stringify(items); });
				continue;
			} else { 
				input=document.createElement('input');
				input.type='text';
				input.value=f.current ?? '';
			}

			// default placement (non-array)
			row.appendChild(input);
			addHelp(input);
			addError();

			function gotoFinalize(placeInput = true, backingInput = input, onBeforeSubmit = null) {
				backingInput.id = f.id;
				backingInput.dataset.key = f.key;
				backingInput.dataset.required = f.required ? '1' : '0';
				if (f.placeholder) backingInput.placeholder = f.placeholder;
				if (f.pattern) backingInput.pattern = f.pattern;

				idByKey.set(f.key, f.id);
				if (placeInput){
					backingInput.addEventListener('keydown', e=>{
						if (e.key === 'Enter' && (backingInput.tagName==='INPUT' || backingInput.tagName==='SELECT')) {
							e.preventDefault();
							(formSubmit).focus();
						}
					});
					backingInput.addEventListener('input', validateForm);
					backingInput.addEventListener('change', validateForm);
				}
				// store per-field submit hook if provided
				if (onBeforeSubmit){
					if (!formState.beforeSubmit) formState.beforeSubmit = {};
					formState.beforeSubmit[f.key] = onBeforeSubmit;
				}
				formBody.appendChild(row);
			}
			gotoFinalize();
		}

		validateForm();
		(formBody.querySelector('input,select,textarea') || formSubmit).focus();
	}

	function validateForm() {
		const inputs = [...formBody.querySelectorAll('input,select,textarea')].filter(el=>el.type!=='hidden');
		let ok = true;
		for (const el of inputs) {
			el.classList.remove('invalid');
			const required = el.dataset.required === '1';
			const v = (el.tagName === 'SELECT') ? el.value : el.value.trim();
			if (required && !v) { ok = false; continue; }
			if (el.pattern) {
				try{
					const re = new RegExp(el.pattern);
					if (v && !re.test(v)) {
						ok = false;
						el.classList.add('invalid'); 
					} 
				} catch { /* bad pattern from host - ignore */ }
			}
		}
		formSubmit.disabled = !ok;
	}

	function closeForm(ok) {
		if (!ok) {
			post({ type: 'FormResult', ok: false });
		} else {
			// let fields with custom backing state (e.g., Array) push latest value
			if (formState?.beforeSubmit) {
				for (const [k,fn] of Object.entries(formState.beforeSubmit)) try{ fn(); }catch{}
			}
			const values = {};
			for (const f of formState.fields) {
				const el = document.getElementById(f.id);
				values[f.key] = (el.tagName === 'SELECT') ? el.value : el.value;
			}
			post({ type: 'FormResult', ok: true, values });
		}
		formOverlay.style.display = 'none';
		document.body.style.overflow = '';
		formState = null;
		idByKey.clear();
		errByKey.clear();
	}

	formCancel.onclick = () => closeForm(false);
	formSubmit.onclick = () => closeForm(true);
	formOverlay.addEventListener('click', e => { if (e.target === formOverlay) closeForm(false); });
	// --- end form controller ---------------------------------------------------------

	// Unified handler
	function handle(raw) {
		try {
			//cwriteline("RX: " + (typeof raw === 'string' ? raw : JSON.stringify(raw)));
			const msg = (typeof raw === 'string') ? JSON.parse(raw) : raw;
			if (!msg || !msg.type) return;
			switch (msg.type) {
				case 'StartRealtime': renderRealtimeBubble(msg.id, msg.title||'Output'); break;
				case 'RealtimeAppend': appendRealtime(msg.id, msg.text||'', !!msg.newline); break;
				case 'RealtimeComplete': completeRealtime(msg.id); break;
				case 'StartProgress': renderProgressBubble(msg.id, msg.title, !!msg.cancellable); break;
				case 'UpdateProgress': updateProgressBubble(msg.id, msg); break;
				case 'CompleteProgress': completeProgressBubble(msg.id, msg.artifact||''); break;				
				case 'AppendMessage': add((msg.role||'').toLowerCase(), msg.content||''); break;
				case 'RenderHistory': consoleEl.innerHTML=''; (msg.items||[]).forEach(x=>add((x.role||'').toLowerCase(), x.content||'')); break;
				case 'ConsoleWrite': cwrite(msg.text||''); break;
				case 'ConsoleWriteLine': cwriteline(msg.text||''); break;
				case 'ShowMenu': openMenu(msg); break;
				case 'ShowForm': openForm(msg); break;
				case 'FocusInput': t.focus(); break;
				case 'PickFilesResult': {
					const { requestId, files } = msg;
					const cb = pendingPickers.get(requestId);
					if (cb) {
						pendingPickers.delete(requestId);
						try { cb(files || []); } catch {}
					}
					break;
				}				
				case 'Clear': consoleEl.innerHTML=''; break;
				case 'FormError': {
					// payload: { type:'FormError', key, message }
					if (!formState) break;
					const { key, message } = msg;
					const id = idByKey.get(key);
					const err = errByKey.get(key);
					if (id && err) {
						const el = document.getElementById(id);
						el?.classList.add('invalid');
						err.textContent = message || 'Invalid value.';
						err.style.display = '';
						el?.focus();
					}
					break;
				}
			}
		}catch(e){ cwriteline(`RX error: ${e.message}`); }
	}
	window.external.receiveMessage(message => handle(message));
	function add(kind, text) {
		const el = document.createElement('div');
		el.className = 'bubble ' + (kind || '');
		el.innerHTML = marked.parse(text ?? '');
		consoleEl.appendChild(el);
		consoleEl.scrollTop = consoleEl.scrollHeight;
	}

	// --- realtime text bubbles ---
	function renderRealtimeBubble(id, title){
		const wrap = document.createElement('div');
		wrap.className = 'bubble tool';
		wrap.dataset.realtimeId = id;
		wrap.innerHTML = `
			<div style="text-align:left">
			<div style="font-weight:700;margin-bottom:8px">${title}</div>
			<pre class="rt" style="white-space:pre-wrap;margin:0"></pre>
			</div>`;
		consoleEl.appendChild(wrap);
		consoleEl.scrollTop = consoleEl.scrollHeight;
	}

	function appendRealtime(id, text, newline){
		const wrap = consoleEl.querySelector(`[data-realtime-id="${id}"]`);
		if (!wrap) return;
		const pre = wrap.querySelector('.rt');
		if (!pre) return;
		pre.textContent += (text||'') + (newline ? '\n' : '');
		consoleEl.scrollTop = consoleEl.scrollHeight;
	}

	function completeRealtime(id){
		const wrap = consoleEl.querySelector(`[data-realtime-id="${id}"]`);
		if (!wrap) return;
		// freeze it as a normal tool bubble (already styled); nothing else required
		wrap.removeAttribute('data-realtime-id');
	}

	// --- progress bubbles ---
	function renderProgressBubble(id, title, cancellable){
		const wrap = document.createElement('div');
		wrap.className = 'bubble tool';
		wrap.dataset.progressId = id;
		wrap.innerHTML = `
			<div style="text-align:left">
			<div style="font-weight:700;margin-bottom:8px">${title}</div>
			<div class="rows"></div>
			<div class="stats" style="margin-top:6px;color:#888;font-size:.9em"></div>
			<div class="actions" style="margin-top:8px;display:flex;gap:8px;justify-content:flex-end;">
				${cancellable ? `<button data-cancel style="padding:6px 10px;border:1px solid #666;background:#222;color:#eee;border-radius:8px;cursor:pointer">Cancel</button>` : ``}
			</div>
			</div>`;
		if (cancellable) {
			wrap.querySelector('[data-cancel]').onclick = () => {
			post({ type:'CancelProgress', id });
			wrap.querySelector('[data-cancel]').disabled = true;
			wrap.querySelector('[data-cancel]').textContent = 'Cancelling…';
			};
		}
		consoleEl.appendChild(wrap);
		consoleEl.scrollTop = consoleEl.scrollHeight;
		return wrap;
	}

	function updateProgressBubble(id, payload){
		const wrap = consoleEl.querySelector(`[data-progress-id="${id}"]`);
		if (!wrap) return;
		const rows = wrap.querySelector('.rows');
		const stats = wrap.querySelector('.stats');

		rows.innerHTML = '';
		const MAX_ROWS = 5;
		const rank = s => (s==='Running'?3 : s==='Queued'?2 : s==='Failed'?1 : s==='Canceled'?0 : -1);

		const active = (payload.items || [])
		.filter(r => r.state !== 'Completed' && r.state !== 'Canceled')
		.sort((a,b) => (rank(b.state)-rank(a.state)) || (a.percent-b.percent) || a.name.localeCompare(b.name))
		.slice(0, MAX_ROWS);

		active.forEach(r => {
		const pct = Math.max(0, Math.min(100, r.percent|0));
		const glyph = r.state==='Running' ? '▶' : r.state==='Completed' ? '✓' : r.state==='Failed' ? '✖' : r.state==='Canceled' ? '■' : '•';
		const right = (r.total>0) ? `${pct}% (${r.done}/${r.total})` : `${pct}%`;
		const bar = document.createElement('div');
		bar.className = 'progress-row';
		bar.style.margin = '6px 0';
		bar.innerHTML = `
			<div style="display:flex;justify-content:space-between;gap:10px">
			<div class="name" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:70%">${glyph} ${r.name}</div>
			<div style="color:#aaa">${right}</div>
			</div>
			<div class="bar" style="height:8px;background:#222;border:1px solid #444;border-radius:9999px;overflow:hidden">
			<div class="fill" style="width:${pct}%;height:100%"></div>
			</div>`;
		const fill = bar.querySelector('.fill');
		if (r.state==='Failed') fill.style.background = '#a11';
		else if (r.state==='Canceled') fill.style.background = '#555';
		else fill.style.background = '#5a9';
		rows.appendChild(bar);
		});


		const s = payload.stats||{};
		stats.textContent = `in-flight: ${s.running||0}   queued: ${s.queued||0}   completed: ${s.completed||0}   failed: ${s.failed||0}   canceled: ${s.canceled||0}` + (payload.eta ? ` • ETA: ${payload.eta}` : '');
		if (!payload.active) {
			const btn = wrap.querySelector('[data-cancel]'); if (btn) btn.remove();
		}
	}

	function completeProgressBubble(id, artifactMarkdown){
		const wrap = consoleEl.querySelector(`[data-progress-id="${id}"]`);
		if (!wrap) return;
		wrap.removeAttribute('data-progress-id');   // it’s not “live” anymore
		wrap.className = 'bubble tool';             // normalize classes
		wrap.innerHTML = marked.parse(artifactMarkdown || '_done_');
		consoleEl.scrollTop = consoleEl.scrollHeight;
	}

	function submit() {
		const v = t.value.trim();
		if (!v) return;
		post({ type:'UserText', text:v });
		t.value = '';
	}

	send.onclick = submit;

	t.addEventListener('keydown', (e) => {
		if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); submit(); }
		else post({ type:'Key', key:e.key, char:e.key.length===1? e.key : '', shift:e.shiftKey, ctrl:e.ctrlKey, alt:e.altKey });
	});

	document.addEventListener('keydown', (e) => {
		if (!menuOverlay.hidden) return;           // menu open → ignore
		if (e.target === t && e.key === 'Enter' && !e.shiftKey) return;
		post({ type:'Key', key:e.key, char:e.key.length===1? e.key : '', shift:e.shiftKey, ctrl:e.ctrlKey, alt:e.altKey });
	});

	// Initial ping → enables .NET flush
	const ping = () => post({ type:'Resize', width: Math.floor(window.innerWidth/8), height: Math.floor(window.innerHeight/18) });
	new ResizeObserver(ping).observe(document.body);
	ping();

	cwriteline('UI ready...');
	t.focus();
</script>
</body>
</html>