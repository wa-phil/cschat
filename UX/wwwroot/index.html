<!doctype html>
<html>
<head>
<meta charset='utf-8'/>
<title>CSChat</title>
<style>
	:root { --bg:#111; --fg:#eee; }
	body { font-family: system-ui, sans-serif; margin:0; height:100vh; display:grid; grid-template-rows:auto 1fr auto; }
	#main  { display:flex; flex-direction:column; }
	#console { flex:1; overflow:auto; padding:12px; white-space:pre-wrap;
				font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; }
	#composer { display:flex; padding:8px; gap:8px; border-top:1px solid #ddd; }
	#t { flex:1; padding:8px; font: inherit; }
	pre { margin:0 0 8px 0; white-space:pre-wrap; }
	.user { color:#08f; } .assistant { color:#0a0; } .tool { color:#aa0 } .system { color:#666; }	
	#menuOverlay {
		position: fixed;
		inset: 0;
		background: rgba(0,0,0,.0); /* transparent so clicks can still close if desired */
		pointer-events: none;         /* disabled when menu is closed */
		z-index: 9999;
	}

	#menuPanel {
		position: absolute;
		top: -90%; /* mostly hidden above */
		left: 50%;
		transform: translateX(-50%);
		width: min(760px, 92vw);
		max-height: min(70vh, 600px);
		background: #fff;
		color: #000;
		border-radius: 0 0 10px 10px;
		box-shadow: 0 20px 50px rgba(0,0,0,.35);
		display: grid;
		grid-template-rows: auto auto 1fr auto;
		overflow: hidden;
		transition: top 0.3s ease-in-out;
	}

	/* active state (pulled down) */
	#menuOverlay.active { pointer-events: auto; }
	#menuOverlay.active #menuPanel { top: 0; /* slide down into view */ }

	/* menu item add/remove animation styles */
	#menuList li {
		padding: 8px 10px;
		border-radius: 8px;
		opacity: 1;
		transform: translateY(0);
		transition: opacity 0.2s ease, transform 0.2s ease;
	}

	#menuList li.fade-out {
		opacity: 0;
		transform: translateY(-10px);
	}

	#menuList li.fade-in {
		opacity: 0;
		transform: translateY(10px);
		animation: fadeInMove 0.2s forwards;
	}

	@keyframes fadeInMove {
		to { opacity: 1; transform: translateY(0); }
	}

	#menuHeader { padding:12px 14px; font-weight:600; background:#111; color:#eee; }
	#menuFilter { margin:10px; padding:10px; font:inherit; border:1px solid #ccc; border-radius:8px; }
	#menuList { list-style:none; margin:0; padding:6px 8px 12px 8px; overflow:auto; }
	#menuList li { padding:8px 10px; border-radius:8px; }
	#menuList li[data-active="true"] { background:#111; color:#fff; }
	#menuHint { padding:8px 12px; font-size:.9em; color:#444; border-top:1px solid #eee; background:#fafafa; }

	#menuTab {
	position: fixed;
	top: 0;
	left: 50%;
	transform: translateX(-50%);
	background: #111;
	color: #eee;
	padding: 4px 10px;
	font-size: 0.85em;
	border-radius: 0 0 6px 6px;
	cursor: pointer;
	z-index: 9998;
	}

	#menuOverlay.active ~ #menuTab {
	display: none;
	}
</style>
<body>
  <header></header>
  <div id="menuTab">press ESC key to open</div>
  <div id='main'>
	<div id='console'></div> <!-- big scrollable console/log -->
  </div>
  <div id='composer'>
	<input id='t' placeholder='Type and press Enter'/>
	<button id='send'>Send</button>
  </div>
	<!-- MENU OVERLAY -->
	<div id="menuOverlay" hidden>
		<div id="menuPanel">
			<div id="menuHeader"></div>
			<input id="menuFilter" placeholder="[filter]" autocomplete="off" />
			<ul id="menuList"></ul>
			<div id="menuHint">↑/↓ select • Enter choose • Esc back/cancel</div>
		</div>
	</div>
<script>
	const consoleEl = document.getElementById('console');
	const t = document.getElementById('t');
	const send = document.getElementById('send');

	function post(obj) { try { window.external?.sendMessage?.(JSON.stringify(obj)); } catch {} }
	function cwrite(s){ consoleEl.textContent += (s ?? ''); consoleEl.scrollTop = consoleEl.scrollHeight; }
	function cwriteline(s){ cwrite((s ?? '') + '\n'); }

	// --- menu controller ---------------------------------------------------------
	const menuOverlay = document.getElementById('menuOverlay');
	const menuHeader  = document.getElementById('menuHeader');
	const menuFilter  = document.getElementById('menuFilter');
	const menuList    = document.getElementById('menuList');

	let menuState = null;         // { header, choices, filtered, idx }

	document.getElementById('menuTab').onclick = () => {
		post({ type:'Key', key:'Escape' }); // mimic ESC keypress to open menu
	};

	function openMenu(payload) {
		menuState = {
			header: payload.header || 'Menu',
			choices: (payload.choices || []).slice(),
			filtered: (payload.choices || []).slice(),
			idx: Math.min(Math.max(0, payload.selected|0), (payload.choices||[]).length-1)
		};

		menuHeader.textContent = menuState.header;
		menuFilter.value = '';
		renderMenu();
		menuOverlay.hidden = false;
		menuOverlay.classList.add('active');
		// Trap focus & keystrokes while menu is open
		menuOverlay.hidden = false;
		document.body.style.overflow = 'hidden';
		t.disabled = true;
		menuFilter.focus();
	}

	function closeMenu(sendResult) {
		menuOverlay.classList.remove('active');
		menuOverlay.hidden = true;

		if (sendResult !== undefined) {
			// Post selection/cancel to host so RenderMenu(...) can return synchronously.
			post({ type:'MenuResult', text: sendResult ?? null });
		}

		document.body.style.overflow = '';
		t.disabled = false;
		t.focus();
	}

	function renderMenu() {
		const q = menuFilter.value.trim().toLowerCase();
		const newItems = q
			? menuState.choices.filter(c => c.toLowerCase().includes(q))
			: menuState.choices.slice();

		// Keep filtered in sync for chooseActive()
		menuState.filtered = newItems;

		// Clamp idx if needed
		if (menuState.filtered.length === 0) menuState.idx = 0;
		else if (menuState.idx >= menuState.filtered.length) menuState.idx = menuState.filtered.length - 1;

		const oldLis   = [...menuList.querySelectorAll('li')];
		const oldTexts = oldLis.map(li => li.dataset.value);

		// Fade-out removes
		oldLis.forEach(li => {
			if (!newItems.includes(li.dataset.value)) {
				li.classList.add('fade-out');
				setTimeout(() => li.remove(), 200);
			}
		});

		// Add missing items (fade-in)
		newItems.forEach((c, i) => {
			if (!oldTexts.includes(c)) {
				const li = document.createElement('li');
				li.dataset.value = c;  // stable key
				li.textContent = c;
				li.classList.add('fade-in');
				li.onclick = () => { menuState.idx = i; chooseActive(); };
				menuList.appendChild(li);
			}
		});

		// Reindex & active state on all survivors (order matters)
		const lis = [...menuList.querySelectorAll('li')];
		lis.sort((a,b) => newItems.indexOf(a.dataset.value) - newItems.indexOf(b.dataset.value))
			.forEach((li, i) => {
				// normalize label
				li.textContent = li.dataset.value;
				// active row
				li.dataset.active = (i === menuState.idx ? 'true' : 'false');
				// click maps to current index
				li.onclick = () => { menuState.idx = i; chooseActive(); };
			});

		// keep active visible
		const active = menuList.querySelector('li[data-active="true"]');
		if (active) {
			const r = active.getBoundingClientRect();
			const pr = menuList.getBoundingClientRect();
			if (r.top < pr.top) menuList.scrollTop += r.top - pr.top;
			else if (r.bottom > pr.bottom) menuList.scrollTop += r.bottom - pr.bottom;
		}
	}

	function chooseActive() {
		const items = menuState.filtered;
		const chosen = (items.length > 0) ? items[menuState.idx] : null;
		closeMenu(chosen);
	}

	// Filter typing
	menuFilter.addEventListener('input', renderMenu);

	// Keyboard in the menu
	menuOverlay.addEventListener('keydown', (e) => {
		// Prevent these from leaking to the host while overlay is open
		if (['ArrowUp','ArrowDown','PageUp','PageDown','Home','End','Escape','Enter'].includes(e.key)) {
			e.stopPropagation(); e.preventDefault();
		}
		const len = menuState.filtered.length;
		switch (e.key) {
			case 'ArrowUp':   if (len) menuState.idx = Math.max(0, menuState.idx-1); renderMenu(); break;
			case 'ArrowDown': if (len) menuState.idx = Math.min(len-1, menuState.idx+1); renderMenu(); break;
			case 'PageUp':    if (len) menuState.idx = Math.max(0, menuState.idx-10);  renderMenu(); break;
			case 'PageDown':  if (len) menuState.idx = Math.min(len-1, menuState.idx+10); renderMenu(); break;
			case 'Home':      if (len) menuState.idx = 0;            renderMenu(); break;
			case 'End':       if (len) menuState.idx = len-1;        renderMenu(); break;
			case 'Enter':     chooseActive(); break;
			case 'Escape':    closeMenu(null); break; // close this menu, let host know it was cancelled
		}
	});

	// Close if user clicks outside the panel
	menuOverlay.addEventListener('click', (e) => {
		if (e.target === menuOverlay) closeMenu(null);
	});
	// --- end menu controller ------------------------------------------------------

  // --- unified handler for ANY host→page message ---
  function handle(raw) {
	try {
	  //cwriteline("RX: " + (typeof raw === 'string' ? raw : JSON.stringify(raw)));
	  const msg = (typeof raw === 'string') ? JSON.parse(raw) : raw;
	  if (!msg || !msg.type) return;

	  switch (msg.type) {
		case 'AppendMessage': add((msg.role||'').toLowerCase(), `[${msg.role}] ${msg.content||''}`); break;
		case 'RenderHistory': consoleEl.innerHTML=''; (msg.items||[]).forEach(x=>add((x.role||'').toLowerCase(), `[${x.role}] ${x.content||''}`)); break;
		case 'ConsoleWrite': cwrite(msg.text||''); break;
		case 'ConsoleWriteLine': cwriteline(msg.text||''); break;
		case 'ShowMenu': openMenu(msg); break;
		case 'PromptLine': post({ type:'UserText', text: prompt('Input:', msg.placeholder||'') || '' }); break;
		case 'PromptPath': post({ type:'UserText', text: prompt('Path:', '') || '' }); break;
		case 'FocusInput': t.focus(); break;
		case 'BeginBatch': break;
		case 'Clear': consoleEl.innerHTML=''; break;
		case 'ShowToast': cwriteline(msg.text||''); break;
	  }
	} catch (e) {
	  cwriteline(`RX error: ${e.message}`);
	}
  }

	// --- wire BOTH channels so we always receive ---
	// Photino shim:
	window.external.receiveMessage(message => handle(message));
	//(window.external ??= {}).receiveMessage = handle;  // safe even if Photino overwrites later

	// Native WebView2:
	// if (window.chrome?.webview?.addEventListener) {
	// 	window.chrome.webview.addEventListener('message', e => handle(e.data));
	// }

  function add(kind, text) {
	const el = document.createElement('pre');
	el.className = kind;
	el.textContent = text;
	consoleEl.appendChild(el);
	consoleEl.scrollTop = consoleEl.scrollHeight;
  }

  function submit() {
	const v = t.value.trim();
	if (!v) return;
	post({ type:'UserText', text:v });
	t.value = '';
  }
  send.onclick = submit;

  t.addEventListener('keydown', (e) => {
	if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); submit(); }
	else post({ type:'Key', key:e.key, char:e.key.length===1? e.key : '', shift:e.shiftKey, ctrl:e.ctrlKey, alt:e.altKey });
  });
  document.addEventListener('keydown', (e) => {
		if (!menuOverlay.hidden) return;           // menu open → ignore
	if (e.target === t && e.key === 'Enter' && !e.shiftKey) return;
	post({ type:'Key', key:e.key, char:e.key.length===1? e.key : '', shift:e.shiftKey, ctrl:e.ctrlKey, alt:e.altKey });
  });

  // Initial ping → enables .NET flush
  const ping = () => post({ type:'Resize', width: Math.floor(window.innerWidth/8), height: Math.floor(window.innerHeight/18) });
  new ResizeObserver(ping).observe(document.body);
  ping();

  cwriteline('UI ready...');
  t.focus();
</script>
</body>
</html>